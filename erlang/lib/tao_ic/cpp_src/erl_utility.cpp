/*
 * $Id$
 */

#include <cstring>
#include <sstream>

#include "ast_expression.h"
#include "global_extern.h"
#include "utl_identifier.h"
#include "utl_string.h"

#include "be_extern.h"
#include "be_global.h"
#include "erl_utility.h"

using namespace std;

erl_name::erl_name(AST_Decl *node, bool local)
{
  // Flattened (C-style) IDL names are used for fully qualified
  // names. Names are stripped of leading underscores and converted
  // to lower case to ensure compatibility.
  string s;

  if (local) {
    s += node->local_name()->get_string();
  } else {
    s += node->flat_name();
  }

  { // strip leading underscores
    string::iterator it(s.begin());
    while (it != s.end()) {
      if (*it != '_') break;
      it = s.erase(it);
    }
  }

  { // convert to lower case
    string::iterator it(s.begin());
    for (; it != s.end(); ++it) {
      *it = tolower(*it);
    }
  }

  str_ = s;
}

erl_name::~erl_name()
{
}

string
erl_name::str() const
{
  return str_;
}

erl_name::operator string() const
{
  return str_;
}

ostream &
operator<<(ostream &os, const erl_name &val)
{
  return os << val.str_;
}

const char *erl_module::ext = ".erl";

erl_module::erl_module(AST_Decl *node)
  : name_(erl_name(node, false))
{
  be_global->get_src_dir(filename_);

  filename_ += name_.str();
  filename_ += ext;
}

erl_module::~erl_module()
{
  if (os_.is_open()) {
    os_.close();
  }
}

const char *
erl_module::filename() const
{
  return filename_.c_str();
}

void
erl_module::add_export(const string &s)
{
  exports_.push_back(s);
}

void
erl_module::add_import(const string &s)
{
  imports_.push_back(s);
}

void
erl_module::add_include(const string &s)
{
  includes_.push_back(s);
}

void
erl_module::generate_header()
{
  os_ << "%%" << endl
      << "%%" << " $" << "Id" << "$" << endl // avoid keyword expansion
      << "%%" << endl
      << "%% Generated by the tao_ic IDL compiler, version " <<
         TAO_IC_VERSION << endl
      << "%%" << endl
      << "%% Source:" << endl
      << "%%   " << idl_global->filename()->get_string() << endl
      << "%%" << endl
      << "%% AUTOMATICALLY GENERATED FILE - DO NOT EDIT!" << endl
      << "%%" << endl;
}

void
erl_module::generate_attributes()
{
  os_ << "-module(" << name_ << ")." << endl;
  if (!imports_.empty()) {
    os_ << "-import(" << to_list(imports_) << ")." << endl;
  }
  if (!exports_.empty()) {
    os_ << "-export(" << to_list(exports_) << ")." << endl;
  }
  os_ << endl;
}

void
erl_module::generate_includes()
{
  if (!includes_.empty()) {
    vector<string>::iterator it (includes_.begin());
    for (; it != includes_.end(); ++it) {
      os_ << "-include(\"" << *it << "\")." << endl;
    }
    os_ << endl;
  }
}

ostream &
erl_module::open_stream(bool auto_generate)
{
  os_.open(filename());

  if (auto_generate) {
    // Generate source header
    generate_header();

    // Generate module attributes
    generate_attributes();

    // Generate module includes
    generate_includes();
  }

  return os_;
}

ostream &
operator<<(ostream &os, const erl_module &val)
{
  return os << val.name_;
}

erl_literal::erl_literal(AST_Expression *e)
  : str_(to_str(e))
{
}

erl_literal::~erl_literal()
{
}

string
erl_literal::str() const
{
  return str_;
}

string
erl_literal::to_str(AST_Expression *e)
{
  ostringstream os;

  AST_Expression::AST_ExprValue *ev = e->ev();
  switch (ev->et) {
  case AST_Expression::EV_short:
    os << ev->u.sval;
    break;
  case AST_Expression::EV_ushort:
    os << ev->u.usval;
    break;
  case AST_Expression::EV_long:
    os << ev->u.lval;
    break;
  case AST_Expression::EV_ulong:
    os << ev->u.ulval;
    break;
#ifndef ACE_LACKS_LONGLONG_T
  case AST_Expression::EV_longlong:
    os << ev->u.llval;
    break;
  case AST_Expression::EV_ulonglong:
    os << ev->u.ullval;
    break;
#endif /* ACE_LACKS_LONGLONG_T */

  case AST_Expression::EV_float:
    os << showpoint << ev->u.fval;
    break;
  case AST_Expression::EV_double:
    os << showpoint << ev->u.dval;
    break;

  case AST_Expression::EV_char:
    os << '$' << ev->u.cval;
    break;
  case AST_Expression::EV_wchar:
    os << '$' << ev->u.wcval;
    break;

  case AST_Expression::EV_octet:
    os << "<<" << unsigned(ev->u.oval) << ">>";
    break;

  case AST_Expression::EV_bool:
    os << boolalpha << ev->u.bval;
    break;

  case AST_Expression::EV_string:
    os << '"' << ev->u.strval->get_string() << '"';
    break;
  case AST_Expression::EV_wstring:
    os << '"' << ev->u.wstrval << '"';
    break;

  default:
    break; // not supported
  }

  return os.str();
}

ostream &
operator<<(ostream &os, const erl_literal &val)
{
  return os << val.str_;
}

string
to_list(vector<std::string> &val)
{
  ostringstream os;

  os << "[";
  vector<string>::iterator it(val.begin());
  while (it != val.end()) {
    os << *it++;
    if (it != val.end()) {
      os << ", ";
    }
  }
  os << "]";

  return os.str();
}
