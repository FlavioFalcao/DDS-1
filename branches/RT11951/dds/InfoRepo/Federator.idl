// -*- C++ -*-
// $Id$
#ifndef TAO_DDS_FEDERATOR_IDL
#define TAO_DDS_FEDERATOR_IDL

#include "dds/DdsDcpsInfrastructure.idl"
#include "dds/DdsDcpsTopic.idl"
#include "dds/DdsDcpsPublication.idl"
#include "dds/DdsDcpsSubscription.idl"
#include "dds/DdsDcpsInfoUtils.idl"

module OpenDDS { module Federator {

    typedef sequence<octet> OctetSeq;

    //
    // Costs associated with a link.  Here we only allow ON (zero cost)
    // and OFF (infinite cost) links to be advertised.  This can be
    // changed if more advanced routing algorithms are to be used.
    //
    enum LinkCost {
      LINK_OFF, // Link can not be used.
      LINK_ON   // Link can be used.
    };

    ////////////////////////////////////////////////////////////////////
    //
    // Contents of the Link State Packets (LSPs).
    //
    // This is the data type published to distribute topology information
    // for repository federation.
    //

// This pragma is TAO specific
#pragma DCPS_DATA_TYPE "OpenDDS::Federator::LinkState"
    struct LinkState {
      OpenDDS::DCPS::RepoId source;      // Source of the advertised link.
      OpenDDS::DCPS::RepoId destination; // Destination of the advertised link.
      LinkCost              cost;        // Cost to use the advertised link.
      long                  packet;      // The sequence number of the instant sample.
    };

    // Unique identifier for a repository.
    typedef long RepoKey;

    // Unique identifier for all entities within federation.
    struct FederationId {
      RepoKey                repository;
      OpenDDS::DCPS::RepoId  handle;
    };

    // Constant values.
    const RepoKey NIL_REPOSITORY     = 0; // Reserved repository Id value.
    const string  LINKSTATETOPICNAME = "LinkState";
    const string  LINKSTATETYPENAME  = "LinkState";

    ////////////////////////////////////////////////////////////////////
    //
    // Topic data updates
    //

// This pragma is TAO specific
#pragma DCPS_DATA_TYPE "OpenDDS::Federator::TopicUpdate"
#pragma DCPS_DATA_KEY  "OpenDDS::Federator::TopicUpdate id.repository"
    struct TopicUpdate {
      FederationId    id;
      FederationId    participant;
      DDS::DomainId_t domain;
      long            packet;      // The sequence number of the instant sample.
      string          topic;
      string          datatype;
      DDS::TopicQos   qos;
    };

    // Constant values.
    const string  TOPICUPDATETOPICNAME = "TopicUpdate";
    const string  TOPICUPDATETYPENAME  = "TopicUpdate";

    ////////////////////////////////////////////////////////////////////
    //
    // Participant data updates
    //

// This pragma is TAO specific
#pragma DCPS_DATA_TYPE "OpenDDS::Federator::ParticipantUpdate"
#pragma DCPS_DATA_KEY  "OpenDDS::Federator::ParticipantUpdate id.repository"
    struct ParticipantUpdate {
      FederationId              id;
      DDS::DomainId_t           domain;
      long                      packet;      // The sequence number of the instant sample.
      DDS::DomainParticipantQos qos;
    };

    // Constant values.
    const string  PARTICIPANTUPDATETOPICNAME = "ParticipantUpdate";
    const string  PARTICIPANTUPDATETYPENAME  = "ParticipantUpdate";

    ////////////////////////////////////////////////////////////////////
    //
    // Publication data updates
    //

// This pragma is TAO specific
#pragma DCPS_DATA_TYPE "OpenDDS::Federator::PublicationUpdate"
#pragma DCPS_DATA_KEY  "OpenDDS::Federator::PublicationUpdate id.repository"
    struct PublicationUpdate {
      FederationId                          id;
      FederationId                          topic;
      FederationId                          participant;
      DDS::DomainId_t                       domain;
      long                                  packet;      // The sequence number of the instant sample.
      DDS::PublisherQos                     publisher_qos;
      DDS::DataWriterQos                    datawriter_qos;

      // The following are the components of
      // OpenDDS::DCPS::TransportInterfaceInfo
      // which do not have TypeSupport created for them.

      // The transport type (.e.g SimpleTCP or SimpleUDP)
      OpenDDS::DCPS::TransportInterfaceId   transport_id;

      // Information about the transport instance that is opaque to all but
      // code specific to that transport implementation.
      OctetSeq                       transport_blob;
    };

    // Constant values.
    const string  PUBLICATIONUPDATETOPICNAME = "PublicationUpdate";
    const string  PUBLICATIONUPDATETYPENAME  = "PublicationUpdate";

    ////////////////////////////////////////////////////////////////////
    //
    // Subscription data updates
    //

// This pragma is TAO specific
#pragma DCPS_DATA_TYPE "OpenDDS::Federator::SubscriptionUpdate"
#pragma DCPS_DATA_KEY  "OpenDDS::Federator::SubscriptionUpdate id.repository"
    struct SubscriptionUpdate {
      FederationId                          id;
      FederationId                          topic;
      FederationId                          participant;
      DDS::DomainId_t                       domain;
      long                                  packet;      // The sequence number of the instant sample.
      DDS::SubscriberQos                    subscriber_qos;
      DDS::DataReaderQos                    datareader_qos;

      // The following are the components of
      // OpenDDS::DCPS::TransportInterfaceInfo
      // which do not have TypeSupport created for them.

      // The transport type (.e.g SimpleTCP or SimpleUDP)
      OpenDDS::DCPS::TransportInterfaceId   transport_id;

      // Information about the transport instance that is opaque to all but
      // code specific to that transport implementation.
      OctetSeq                       transport_blob;
    };

    // Constant values.
    const string  SUBSCRIPTIONUPDATETOPICNAME = "SubscriptionUpdate";
    const string  SUBSCRIPTIONUPDATETYPENAME  = "SubscriptionUpdate";

    //
    // Exceptions.
    //

    // Attempt to federate with an unavailable repository.
    exception Unavailable {};

    // Unable to remove a connection.
    exception ConnectionBusy {};

    //
    // Execution status.
    //
    enum Status {
      Federated,
      Already_Federated,
      Unfederated,
      Joining,
      Error_While_Federating
    };

    ////////////////////////////////////////////////////////////////////
    //
    // Federation manager interface.
    //
    interface Manager {
      //
      // Become federated with a repository at the given endpoint.
      //
      // This method will attempt to obtain a remote reference to the
      // DCPSInfoRepo and Federator::Manager objects using the IORTable
      // at the endpoint and perform federation initialization using them.
      //
      // It will search for the objects at:
      //
      //  corbaloc:iiop:$(endpoint)/DCPSInfoRepo
      //  corbaloc:iiop:$(endpoint)/Federator
      //
      Status join_federation( in string  endpoint ) raises ( Unavailable);

      //
      // Remove a connection with a remote repository.
      //
      // This method will attempt to remove a connection to a remote
      // repository, including dropping the references to the
      // DCPSInfoRepo and Federator::Manager objects.  If portions of the
      // federation become unreachable as a result, then they are removed
      // from the federation.
      //
      Status remove_connection( in RepoKey remoteId) raises ( ConnectionBusy);

      //
      // Obtain the value of federation Id for this instance.
      //
      RepoKey federationId();

    };

    // Constant values.
    const string  REPOSITORY_IORTABLE_KEY = "DCPSInfoRepo";
    const string  FEDERATOR_IORTABLE_KEY  = "Federator";

}; }; // End of OpenDDS::Federator

#endif /* TAO_DDS_FEDERATOR_IDL */

