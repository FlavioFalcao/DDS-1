/*
 * $Id$
 */

#include <cstring>
#include <sstream>

#include "ast_expression.h"
#include "global_extern.h"
#include "utl_identifier.h"
#include "utl_string.h"

#include "be_extern.h"
#include "be_global.h"
#include "erl_utility.h"

using namespace std;

const char *erl_module::ext = ".erl";

erl_module::erl_module(AST_Decl *node)
  : module_name_(to_module_name(node))
{
  be_global->get_src_dir(this->filename_);

  this->filename_ += this->module_name_;
  this->filename_ += erl_module::ext;
}

erl_module::~erl_module()
{
  if (this->os_.is_open()) {
    this->os_.close();
  }
}

void
erl_module::add_export(const char *s)
{
  this->exports_.push_back(s);
}

void
erl_module::add_import(const char *s)
{
  this->imports_.push_back(s);
}

void
erl_module::add_include(const char *s)
{
  this->includes_.push_back(s);
}

const char *
erl_module::filename() const
{
  return this->filename_.c_str();
}

void
erl_module::generate_header()
{
  this->os_
    << "%%" << endl
    << "%%" << " $" << "Id" << "$" << endl // avoid keyword expansion
    << "%%" << endl
    << "%% Generated by the tao_ic IDL compiler, version " <<
       TAO_IC_VERSION << endl
    << "%%" << endl
    << "%% Source:" << endl
    << "%%   " << idl_global->filename()->get_string() << endl
    << "%%" << endl
    << "%% AUTOMATICALLY GENERATED FILE - DO NOT EDIT!" << endl
    << "%%" << endl;
}

void
erl_module::generate_attributes()
{
  this->os_ << "-module(" << this->module_name_ << ")." << endl;

  if (!this->imports_.empty()) {
    this->os_ << "-import(" << to_list(this->imports_) << ")." << endl;
  }

  if (!this->exports_.empty()) {
    this->os_ << "-export(" << to_list(this->exports_) << ")." << endl;
  }

  this->os_ << endl;
}

void
erl_module::generate_includes()
{
  if (!this->includes_.empty()) {
    vector<const char *>::iterator it (this->includes_.begin());
    for (; it != this->includes_.end(); ++it) {
      this->os_ << "-include(\"" << *it << "\")." << endl;
    }

    this->os_ << endl;
  }
}

ostream &
erl_module::open_stream(bool auto_generate)
{
  this->os_.open(filename());

  if (auto_generate) {
    // Generate source header
    generate_header();

    // Generate module attributes
    generate_attributes();

    // Generate module includes
    generate_includes();
  }

  return this->os_;
}

string
erl_module::to_list(vector<const char *> &list)
{
  ostringstream os;

  os << "[";
  vector<const char *>::iterator it(list.begin());
  while (it != list.end()) {
    os << *it++;
    if (it != list.end()) {
      os << ", ";
    }
  }
  os << "]";

  return os.str();
}

string
erl_module::to_module_name(AST_Decl *node)
{
  // Flattened (C-style) IDL names are used for erlang module names.
  // Module names are stripped of leading underscores and converted
  // to lower case to ensure compatibility.
  
  string s(node->flat_name());

  { // strip leading underscores
    string::iterator it(s.begin());
    while (it != s.end()) {
      if (*it != '_') break;
      it = s.erase(it);
    }
  }

  { // convert to lower case
    string::iterator it(s.begin());
    for (; it != s.end(); ++it) {
      *it = tolower(*it);
    }
  }

  return s;
}

erl_literal::erl_literal(AST_Expression *e)
  : str_(to_str(e))
{
}

erl_literal::~erl_literal()
{
}

string
erl_literal::str() const
{
  return this->str_;
}

string
erl_literal::to_str(AST_Expression *e)
{
  ostringstream os;

  AST_Expression::AST_ExprValue *ev = e->ev();
  switch (ev->et) {
  case AST_Expression::EV_short:
    os << ev->u.sval;
    break;
  case AST_Expression::EV_ushort:
    os << ev->u.usval;
    break;
  case AST_Expression::EV_long:
    os << ev->u.lval;
    break;
  case AST_Expression::EV_ulong:
    os << ev->u.ulval;
    break;
#ifndef ACE_LACKS_LONGLONG_T
  case AST_Expression::EV_longlong:
    os << ev->u.llval;
    break;
  case AST_Expression::EV_ulonglong:
    os << ev->u.ullval;
    break;
#endif /* ACE_LACKS_LONGLONG_T */

  case AST_Expression::EV_float:
    os << showpoint << ev->u.fval;
    break;
  case AST_Expression::EV_double:
    os << showpoint << ev->u.dval;
    break;

  case AST_Expression::EV_char:
    os << '$' << ev->u.cval;
    break;
  case AST_Expression::EV_wchar:
    os << '$' << ev->u.wcval;
    break;

  case AST_Expression::EV_octet:
    os << "<<" << unsigned(ev->u.oval) << ">>";
    break;

  case AST_Expression::EV_bool:
    os << boolalpha << ev->u.bval;
    break;

  case AST_Expression::EV_string:
    os << '"' << ev->u.strval->get_string() << '"';
    break;
  case AST_Expression::EV_wstring:
    os << '"' << ev->u.wstrval << '"';
    break;

  default:
    break; // not supported
  }

  return os.str();
}

ostream &
operator<<(ostream &os, const erl_literal &el)
{
  return os << el.str();
}
