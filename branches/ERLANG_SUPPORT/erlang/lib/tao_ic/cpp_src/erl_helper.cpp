/*
 * $Id$
 */

#include <cctype>
#include <string>

#include "global_extern.h"
#include "utl_identifier.h"
#include "utl_string.h"

#include "be_extern.h"
#include "be_global.h"
#include "erl_helper.h"

using namespace std;

const char *erl_helper::ext = ".erl";

erl_helper::erl_helper(AST_Decl *node)
{
  this->module_ = to_module(node);
}

erl_helper::~erl_helper()
{
  if (this->out_.is_open()) {
    this->out_.close();
  }
}

void
erl_helper::add_export(const char *s)
{
  this->exports_.push_back(s);
}

void
erl_helper::add_import(const char *s)
{
  this->imports_.push_back(s);
}

void
erl_helper::add_include(const char *s)
{
  this->includes_.push_back(s);
}

const char *
erl_helper::filename()
{
  ACE_CString s(be_global->output_dir_src());

  s += this->module_;   // module name
  s += erl_helper::ext; // .erl extension

  return s.c_str();
}

void
erl_helper::generate_header()
{
  this->out_
    << "%%" << endl
    << "%% $Id$" << endl
    << "%%" << endl
    << "%% Generated by the tao_ic IDL compiler, version " <<
       TAO_IC_VERSION << endl
    << "%%" << endl
    << "%% Source:" << endl
    << "%%   " << idl_global->filename()->get_string() << endl
    << "%%" << endl
    << "%% AUTOMATICALLY GENERATED FILE - DO NOT EDIT!" << endl
    << "%%" << endl;
}

void
erl_helper::generate_attributes()
{
  this->out_ << "-module('" << this->module_ << "')."<< endl;

  if (!this->imports_.empty()) {
    this->out_ << "-import(" << to_list(this->imports_) << ")." << endl;
  }

  if (!this->exports_.empty()) {
    this->out_ << "-export(" << to_list(this->exports_) << ")." << endl;
  }

  this->out_ << endl;
}

void
erl_helper::generate_includes()
{
  if (!this->includes_.empty()) {
    vector<const char *>::iterator it (this->includes_.begin());
    while (it != this->includes_.end()) {
      this->out_ << "-include(\"" << *it << "\")." << endl;
    }
    this->out_ << endl;
  }
}

ofstream &
erl_helper::open_stream(bool auto_generate)
{
  this->out_.open(this->filename());

  if (auto_generate) {
    // Generate source header
    this->generate_header();

    // Generate module attributes
    this->generate_attributes();

    // Generate module includes
    this->generate_includes();
  }

  return this->out_;
}

const char *
erl_helper::to_list(vector<const char *> &list)
{
  string s("[");
  
  vector<const char *>::iterator it(list.begin());
  while (it != list.end()) {
    s += *it;
    if (++it != list.end()) {
      s += ", ";
    }
  }
  s += "]";

  return s.c_str();
}

const char *
erl_helper::to_module(AST_Decl *node)
{
  // Flattened (C-style) IDL names are used for erlang module names.
  // Names are converted to lower case, and should always be escaped
  // (single quoted) in generated source:
  string s(node->flat_name());

  string::iterator it(s.begin());
  for (; it != s.end(); ++it) {
    *it = tolower(*it);
  }
  return s.c_str();
}
