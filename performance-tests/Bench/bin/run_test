eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
    & eval 'exec perl -S $0 $argv:q'
    if 0;

# $Id$
# -*- perl -*-

# Locate the project - *before* we use it to locate Perl modules
use FindBin;
my $projectRoot;
BEGIN { $projectRoot = "$FindBin::Bin/.."; }

# Use information from the environment.
use Env qw( @LD_LIBRARY_PATH
            @LIB_PATH
            @SHLIB_PATH
            @PATH
            $DDS_ROOT
            $ACE_ROOT);

# Locate the Perl modules
use lib "$ACE_ROOT/bin";
use lib "$DDS_ROOT/bin";
use lib "$projectRoot/bin";
use PerlDDS::Run_Test;

########################################
#
# Locate the link libraries
# PerlDDS::add_lib_path( "$projectRoot/lib");
#  NOTE: add_lib_path() does not appear to export the path to the
#        subprocess sufficiently for use by our subprocesses.
unshift @LD_LIBRARY_PATH, "$projectRoot/lib";
unshift @LIB_PATH,        "$projectRoot/lib";
unshift @SHLIB_PATH,      "$projectRoot/lib";

# I find this a particularly heinous setting.
if( $^O eq 'MSWin32') { unshift @PATH, "$projectRoot/lib"; }
#
########################################

use Getopt::Long qw( :config bundling) ;
use Pod::Usage ;

my $status = 0;
my $failed = 0;

#
# Basic options.
#
my $debug;
my $man;
my $help;
my $verbose;
my $orbVerbose;
my $dFile;
my $rawData;
my $rawSize = 4 * 1024;
my $transportDebug;
my $repoDebug;
my $noaction;

#
# Specific options.
#
my $duration;
my $startRepo;
my $startTest;
my $repoHost;
my $iniFile  = $projectRoot . "/etc/transport.ini";
my $scenarios;
my $collectStats;

########################################################################
#
# Process the command line.
#
#   -v -V -? -d -T -R -x -f -C -r -h -s -i -S -P -t
#
GetOptions( "verbose!"            => \$verbose,
            "v"                   => \$verbose,
            "ORBVerboseLogging|V" => \$orbVerbose,
            "help|?"              => \$help,
            "man"                 => \$man,
            "debug|d=i"           => \$debug,
            "tdebug|T=i"          => \$transportDebug,
            "rdebug|R=i"          => \$repoDebug,
            "noaction|x"          => \$noaction,
            "dfile|f=s"           => \$dFile,
            "collect|C"           => \$collectStats,
            "rawdatafile|r=s"     => \$rawData,
            "repohost|h=s"        => \$repoHost,
            "inifile|i=s"         => \$iniFile,
            "scenario|s=s"        => \$scenarios,
            "startrepo|S"         => \$startRepo,
            "starttest|P"         => \$startTest,
            "duration|t=i"        => \$duration,

) or pod2usage( 0) ;
pod2usage( 1)             if $help or ($startTest and not $scenarios);
pod2usage( -verbose => 2) if $man;
#
########################################################################

# Extract the individual scenarios.
my @scenario = split( ',', $scenarios);

# Verbosity.
print "Commands will be printed only and not executed.\n"
                                          if $verbose and $noaction;
print "Repository will be started\n"      if $verbose and $startRepo;
print "Test process will be started\n"    if $verbose and $startTest;
print "Test will execute for at least $duration seconds before terminating\n"
                                          if $verbose and $duration;
print "Test will execute continuously and not terminate\n"
                                          if $verbose and not $duration;
print "ProjectRoot==$projectRoot\n"       if $verbose;
print "RepoHost==$repoHost\n"             if $verbose;
print scalar(@scenario) . " scenarios==" . join(', ', @scenario) . "\n"
                                          if $verbose;
print "RawDataFile==$rawData\n"           if $verbose and $rawData;
print "System Statistics will be collected.\n"
                                          if $verbose and $collectStats;

print "Debug==$debug\n"                   if $verbose and $debug;
print "RepoDebug==$repoDebug\n"           if $verbose and $repoDebug;
print "TransportDebug==$transportDebug\n" if $verbose and $transportDebug;
print "DebugFile==$dFile\n"               if $verbose and $dFile;
print "VerboseLogging==$orbVerbose\n"     if $verbose and $orbVerbose;

# Kill processes after specified duration plus a one minute grace period
# if they do not terminate independently.
my $killDelay = 60;
$killDelay += $duration if $duration;

# Files.
my $repo_ior  = PerlACE::LocalFile("repo.ior");
my $debugFile;
   $debugFile = PerlACE::LocalFile( $dFile) if $dFile;
my $confFile  = $projectRoot . "/etc/svc.conf";

# Clean out leftovers.
unlink $repo_ior;
unlink $debugFile if $debugFile;

my $common_opts = new PerlACE::ConfigList->check_config ('STATIC') ? ''
    : "-ORBSvcConf $confFile";
$common_opts .= $verboseDebug if $verboseDebug;
$common_opts .= "-DCPSTransportDebugLevel $transportDebug " if $transportDebug;

# Establish process arguments.

my $appDebug;
$appDebug  = $debug if $debug;

my $verboseDebug;
$verboseDebug = "-ORBVerboseLogging 1 " if $orbVerbose;

my $repoOpts = "$common_opts ";
$repoOpts .= "-ORBListenEndpoints $repoHost " if $repoHost;
$repoOpts .= "-DCPSDebugLevel $repoDebug " if $repoDebug;
$repoOpts .= "-ORBLogFile $debugFile " if ($repoDebug or $transportDebug) and $debugFile;

my $index = 0;
my $testOpts = "$common_opts ";
$testOpts .= "-v " if $verbose;
$testOpts .= "-DCPSConfigFile $iniFile " if $iniFile;
$testOpts .= "-DCPSDebugLevel $appDebug " if $appDebug;
$testOpts .= "-ORBLogFile $debugFile " if ($appDebug or $transportDebug) and $debugFile;
$testOpts .= "-DCPSInfoRepo corbaloc:iiop:$repoHost/DCPSInfoRepo ";
$testOpts .= "-d $duration " if $duration;
$testOpts .= "-t newest -s $rawSize -r $rawData " if $rawData;


# Define the processes.
my @PROCESSES;

if( $startRepo) {
  my $repoArgs = "$repoOpts -o $repo_ior ";
  if( PerlACE::is_vxworks_test()) {
    push @PROCESSES, new PerlACE::ProcessVX( "$FindBin::Bin/DCPSInfoRepo", $repoArgs);
  } else {
    push @PROCESSES, new PerlACE::Process( "$FindBin::Bin/DCPSInfoRepo", $repoArgs);
  }
}

if( $startTest) {
  map {
    my $testArgs = "$testOpts -f $_ ";
    if( PerlACE::is_vxworks_test()) {
      push @PROCESSES, new PerlACE::ProcessVX( "$FindBin::Bin/testprocess", $testArgs);
    } else {
      push @PROCESSES, new PerlACE::Process( "$FindBin::Bin/testprocess", $testArgs);
    }
  } @scenario;
}

if( $noaction) {
  # Be verbose.
  map { print $_->CommandLine() . "\n"; } @PROCESSES;
  exit;
}

# Manage statistics collection processes.
my @COLLECTORS;
my @HANDLES;
&collectSystemStats( $$)  if $collectStats;

# Start and stop the test processes.
map {
  print "\nTEST PROCESS\n";
  print $_->CommandLine() . "\n";
  $_->Spawn();
  &collectProcessStats( $_->{PROCESS}) if $collectStats;
  &collectNetworkStats( $_->{PROCESS}) if $collectStats;
} @PROCESSES;

# block forever if no duration was specified.
WaitForUserInput() if not $duration;

# Wait for the test processes to terminate nicely.  Terminate in reverse
# order from starting order.
map {
  if ($duration) {
    $status = $_->WaitKill( $killDelay);
  } else {
    $status = $_->TerminateWaitKill( $killDelay);
  }
  print "Terminated test process.\n" if $verbose;
  if( $status != 0) {
    print STDERR "ERROR: Test returned $status\n";
    ++$failed;
  }
  $killDelay = 5;
} reverse @PROCESSES;

# Clean up after the repository.
if( $startRepo) {
  unlink $repo_ior;
}

# Terminate the statistics collectors.
kill 3, @COLLECTORS;

# Report results.
if( $failed == 0) {
  print "test PASSED.\n";

} else {
  print STDERR "test FAILED.\n";
}

exit $failed;

sub WaitForUserInput {
  print "\n\nNo Duration specified.  Hit Enter to end the processes "
      . "and finish the test.\n\n";
  my $userinput = <STDIN>;
}

sub collectProcessStats {
  my $pid = shift;
  if( $pid and $^O ne 'MSWin32') {
    &runCollector(
      "top -bd 1 -p $pid",
      "process-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n" if $input =~ /$pid/;
      }
    );
  }
}

sub collectSystemStats {
  my $pid = shift;
  if( $pid and $^O ne 'MSWin32') {
    &runCollector(
      "vmstat 1",
      "system-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n";
      }
    );
  }
}

sub collectNetworkStats {
  my $pid = shift;
  if( $pid and $^O ne 'MSWin32') {
    &runCollector(
      "netstat -ntpc",
      "network-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n" if $input =~ /$pid/;
      }
    );
  }
}

sub runCollector {
  my ( $command, $filename, $action) = @_;

  # Start a sub-process to collect statistics.
  my $child = open( my $handle, "-|");
  if( not defined($child)) { # Broken
    warn "Unable to start statistics collection: $!";

  } elsif( $child) { # Parent
    # Obtain the statistics process Id to terminate processing with.
    my $cmd = <$handle>;
    chomp $cmd;
    push @COLLECTORS, $cmd; # For terminating.
    push @HANDLES, $handle; # For process scope.
    print "Starting to write statistics to <$filename> "
        . "from process <$cmd> running <$command>.\n";

  } else { # Child
    # Prevent issues with test process management in the child.  The
    # managed processes are managed only by the parent process.
    map $_->{RUNNING} = 0, @PROCESSES;

    # Start collecting using the provided command as input.
    my $cmd = open( STATSIN, "$command |")
      or die "Failed to start statistics gathering command <$command>: $!";

    # Send the command PID to the parent process.
    print "$cmd\n";

    # Open and unbuffer the output.
    open( my $output, "> $filename")
      or die "Failed to open statistics output file <$filename>: $!";
    select $output; $!=1;

    # Process all of the input.
    while(<STATSIN>) {
      s/\s+$//; # Elide trailing whitespace; 'chomp' doesn't work quite right.
      $action->( "$_", $output);
    }

    # Done collecting.
    close $output;
    exit;
  }
}

=head1 NAME

run_test - Execute the test process for a distributed test.

=head1 SYNOPSIS

./run_test [options]

Options:

  -? | --help            brief help message

  --man                  full documentation

  -x | --noaction        do not execute any processing

  -v | --verbose         be chatty while executing

  -V | --ORBVerboseLogging=NUMBER
                         set the corresponding ORB option

  -d NUMBER | --debug=NUMBER
                         set the DCPS debugging level

  -T NUMBER | --tdebug=NUMBER
                         set the DCPSTransportDebug debugging level

  -R NUMBER | --rdebug=NUMBER
                         set the DCPS debugging level for the repository

  -f FILE | --dfile=FILE set the filename for debug output

  -C | --collect         collect process and system statistics during test

  -h FQDN | --repohost FQDN
                         fully qualified domain name (and port) for
                         connecting to repository

  -i FILE | --inifile FILE
                         file for configuring the OpenDDS service

  -s FILELIST | --scenario FILELIST
                         list of files defining the test scenario(s) to execute

  -r FILE | --rawdatafile FILE
                         file to write collected data to at end of test

  -t NUMBER | --duration=NUMBER
                         limit the duration of test execution

  -S | --startrepo       start a repository

  -P | --starttest       start a testprocess

=head1 OPTIONS

=over 8

=item B<-?> | B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<-x> | B<--noaction>

Print the commands that would be executed with the current set of command
line options and exit without performing any processing.

=item B<-v> | B<--verbose>

Print additional information while executing.

=item B<-V> | B<--ORBVerboseLogging=NUMBER>

Sets the -ORBVerboseLogging option to NUMBER.

The default value is 0.

The value is set to 1 if the single letter form isused (-V).

=item B<-d NUMBER> | B<--debug=NUMBER>

Sets the -DCPSDebugLevel option value.

The default value is 0.

=item B<-T NUMBER> | B<--tdebug=NUMBER>

Sets the -DCPSTransportDebugLevel option value.

The default value is 0.

=item B<-R NUMBER> | B<--rdebug=NUMBER>

Sets the -DCPSDebugLevel option value for the repository process.

The default value is 0.

=item B<-t NUMBER> | B<--duration=NUMBER>

Limits the execution time of the test.  If not specified, then any test
or repository process that is started will execute until the script is
interrupted.

The default value is unspecified.

=item B<-S> | B<--startrepo>

Causes a repository process to be started.

The default value is to not start a repository process.

=item B<-P> | B<--starttest>

Causes a test process to be started.

The default value is to not start a test process.

=item B<-f FILE> | B<--dfile=FILE>

Sets the -ORBLogFile option value.

The default value is 0.

=item B<-C> | B<--collect>

Starts the system 'vmstat' to collect system statistics and the 'top'
command in batch mode to collect process statistics.  The system
statistics are collected in the file 'system-stats.log' which is
overridden each time this script is run.  The process statistics are
collected in files named 'process-<pid>.log'.

The default is off - do not collect statistics.

=item B<-h FQDN> | B<--repohost=FQDN>

This is the fully qualified domain name and port where the OpenDDS
repository may be found.

The default value is 'localhost:2112'.

=item B<-i FILE> | B<--inifile=FILE>

OpenDDS configuration filename.  This defines the configuration
information for the OpenDDS service itself.

The default is to use the file located in the 'etc' directory relative
from the project root (the parent directory of the directory where the
command was executed from) with filename 'transport.ini'.

=item B<-s FILELIST> | B<--scenario=FILELIST>

Test scenario definition filenames.  This defines the scenarios to execute
for the test.  This names an 'ini' style file that contains information
about all publications and subscriptions to execute for this test
execution.  This can be one or more filenames, separated by commas.  One
test process will be started (if requested) to process each named
scenario configuration file.

There is no default value, and the test will not execute if not
specified.

=item B<-r FILE> | B<--rawdatafile=FILE>

Raw data output filename.  This file is where any raw latency data
collected during the test will be written.

There is no default value, so no data will be reported by default.

=back

=head1 DESCRIPTION

This script manages execution of the processes needed for distributed
testing of OpenDDS.  The processes used by the OpenDDS-Bench performance
testing framework include the OpenDDS specific repository process and the
test specific process.  The repository executable is the standard OpenDDS
C<DCPSInfoRepo> program.  The framework C<testprocess> program is
specific to this testing and provides the ability to start multiple
publishers and / or subscribers within a single process.

It is possible to start any number of C<testprocess> programs at once.
A separate process will be started for each configuration file supplied.
The same configuration file can be included more than once to start
separate processes with the same configuration.

Processes started by this script will either execute until terminated by
the user (no duration specified) or until a specified duration has
elapsed.  For the C<testprocess> commands, the duration is passed to the
program to allow it to terminate cleanly.  The script will wait 60
seconds beyond this time and then terminate the process by force.

This script will establish the environment for the executable processes
by adding the test library to the runtime library search path.

=head1 EXAMPLES

=over 8

=item B<bin/run_test -vx -s s1.ini>

=item B<bin/run_test -d 10 -T 4 -s test.ini -f test.log -h localhost:2038>

=item B<bin/run_test -x -t multicast -s scenario1.ini>

=item B<bin/run_test -vd10T4V -s test.ini -h machine.domain.com:2112>

=back

=cut

__END__

# vim: filetype=perl

